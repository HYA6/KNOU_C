/*
	포인터 정리
	작성 일자 : 2024.05.17(포인터, 함수, void형 포인터, 포인터 연산)
				2024.05.30(포인터와 배열)
*/

#include <stdio.h>
int change(int*); // 포인터를 매개변수로 갖는 함수 원형 선언
void main() {
	//int *p; // c++ 기반이라 초기화하지 않으면 안됨
	int i = 50;
	int *p = &i;
	
	printf("포인터 변수 p가 가르키는 주소(p)는 %d \n", p); // 변수 i의 주소
	printf("포인터 변수 p의 주소(&p)는 %d \n", &p); // 선언된 포인터 변수의 주소
	printf("포인터 변수 p의 값(*p)은 %d \n", *p);
	printf("정수형 변수 i의 주소(&i)는 %d \n", &i);
	printf("정수형 변수 i의 값(i)은 %d \n", i);
	printf("----------------------------------------------\n");

	// 주소에 입력되는 값만 변경, 주소는 변경X
	i = 70; // *p = 70; 이랑 같음
	printf("포인터 변수 p가 가르키는 주소(p)는 %d \n", p); // 변동X
	printf("포인터 변수 p의 주소(&p)는 %d \n", &p); // 변동X
	printf("포인터 변수 p의 값(*p)은 %d \n", *p); // 값만 변경
	printf("정수형 변수 i의 주소(&i)는 %d \n", &i); // 변동X
	printf("정수형 변수 i의 값(i)은 %d \n", i);
	printf("----------------------------------------------\n");

	// 새로운 주소 대입, 값은 같음
	int k = 70;
	p = &k;
	printf("포인터 변수 p가 가르키는 주소(p)는 %d \n", p); // 주소 자체가 변경
	printf("포인터 변수 p의 주소(&p)는 %d \n", &p); // 변동X
	printf("포인터 변수 p의 값(*p)은 %d \n", *p); // 변동X
	printf("정수형 변수 k의 주소(&k)는 %d \n", &k);
	printf("정수형 변수 k의 값(k)은 %d \n", k); // 변동X
	printf("==============================================\n");
	/*
		즉, 한 번 선언된 포인터 변수의 주소는 변하지 않음
		포인터 변수가 가르키는 주소는 변수의 주소가 됨
		단, 새로 실행할 경우 주소는 항상 가변적임
	*/

	// 포인터를 매개변수로 사용하는 함수 호출
	change(p);
	printf("함수 호출 이후의 k의 주소(&k)는 %d \n", &k); // 변동X
	printf("함수 호출 이후의 k의 값(k)은 %d \n", k);
	printf("==============================================\n");

	// void형 포인터
	int a = 100;
	char b = 'b';
	void* q = NULL;
	q = (int*) &a; // int 자료형 크기만큼 접근할 수 있도록 저장하라는 의미에서 (int*)를 붙인다. a가 변경되는 게 아님
	printf("*q = %d \n", *(int*)q); // void형 포인터는 사용할 때 반드시 명시적 형변환을 해야한다.
	q = (char*) &b;
	printf("*q = %c \n", *(char*)q);
	printf("==============================================\n");

	// 포인터 연산
	int* s = NULL, c[] = { 10, 20, 30, 40, 50 };
	s = &c[0];
	printf("*s      == %d \n", *s); // 출력 : 10, *s == a[0] == 10
	printf("(*s)++  == %d \n", (*s)++); // 출력 후 증가, 값만 1 증가됨 ==> 출력: 10, *s == a[0] == 11
	printf("*s++    == %d \n", *s++); // 출력 후 증가, 주소가 1 증가됨 ==> 출력: 11, *s == a[1]
	printf("++(*s)  == %d \n", ++(*s)); // 증가 후 출력, 값만 1 증가됨 ==> 출력: 21, *s == a[1] == 21
	printf("*++s    == %d \n", *++s); // 증가 후 출력, 주소가 1 증가됨 ==> 출력: 30, *s == a[2]
	printf("==============================================\n");

	// 포인터와 배열
	int d[] = { 10, 20, 30, 40, 50 };
	int e[2][3] = {{1, 2}, {4, 5}};
	int* pa = NULL;
	pa = d; // 배열명을 사용하여 1차원 배열의 시작 주소 할당
	printf("d[1] = %d, *(pa+1) = %d, *pa+1 = %d\n", d[1], *(pa+1), *pa+1);
	pa = e[0]; // 배열명을 사용하여 2차원 배열의 시작 주소 할당
	printf("e[0][1] = %d, *(pa+1) = %d, *(pa+3) = %d\n", e[0][1], *(pa+1), *(pa+3));
	printf("==============================================\n");

}

// 포인터를 매개변수로 사용하는 함수
int change(int *k) {
	return *k += *k;
}